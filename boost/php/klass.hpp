//
// Copyright 2008 (C) Moriyoshi Koizumi. All rights reserved.
//
// This software is distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef MOZO_PHP_KLASS_DEFINED
#define MOZO_PHP_KLASS_DEFINED
#include <new>
#include <cstddef>
#include <cstdlib>
#include <zend_API.h>
#include <boost/mpl/vector.hpp>
#include <mozo/php/detail/function_template.hpp>
#include <mozo/php/detail/function_container.hpp>
#include <mozo/php/detail/object_retriever.hpp>
#include <mozo/php/object.hpp>
#include <mozo/php/exceptions.hpp>
#include <iostream>

namespace mozo { namespace php {

template<typename T_>
class klass: public ::zend_class_entry, public function_container<klass<T_> > {
    friend class object_retriever<T_>;
    friend class to_native_converter<T_, false>;
public:
    typedef T_ object_type;

protected:
    struct zo_wrapper: public sensible_object {
        zo_wrapper(zend_class_entry const& ce TSRMLS_DC)
            : sensible_object(ce TSRMLS_CC), data_initialized(true /* XXX */) {}

        bool data_initialized;
        unsigned char data[sizeof(object_type)];
    };

public:
    klass(char const* _name) {
        TSRMLS_FETCH();
        type = ZEND_INTERNAL_CLASS;
        zend_initialize_class_data(this, true TSRMLS_CC);
        ce_flags = 0;
        name_length = strlen(_name);
        name = static_cast<char*>(::std::malloc(name_length + 1));
        if (!name)
            throw ::std::bad_alloc();
        ::std::memcpy(name, _name, name_length + 1);
        create_object = reinterpret_cast<
            ::zend_object_value(*)(::zend_class_entry* TSRMLS_DC)>(&__factory);
    }

    template<typename Tsig_>
    function_entry const& define_function(
            ::std::string const& name, Tsig_ const& sig) {
        function_entry const& retval =
            function_container<klass>::define_function(name, sig);
        builtin_functions = *this;
        return retval;
    }

    template<typename Targs_>
    klass& ctor(Targs_) {
        typedef detail::unbound_function<detail::constructor_mark, T_, Targs_>
                ctor_type;
        define_function(ZEND_CONSTRUCTOR_FUNC_NAME,
                detail::signature<ctor_type>(ctor_type()));
        constructor = &(
                *(--reinterpret_cast<hashtable< ::zend_function>&>(
                        function_table).end())).second;
    }

    void fixup() {
        TSRMLS_FETCH();
        MOZO_PHP_BEGIN_CAPTURE_ERROR
        if (FAILURE == ::zend_register_functions(
                this, *this,
                &function_table, MODULE_PERSISTENT TSRMLS_CC)) {
            throw runtime_error(MOZO_PHP_LAST_ERROR);
        }
        MOZO_PHP_END_CAPTURE_ERROR
    }

    static void* operator new(std::size_t sz) {
        void* retval = ::std::malloc(sz);
        if (!retval)
            throw ::std::bad_alloc();
        return retval;
    }

    static void operator delete(void* ptr) {
        ::std::free(ptr);
    }

private:
    static ::zend_object_value __factory(klass* self TSRMLS_DC) {
        zend_object_value retval;

        zo_wrapper* obj = new zo_wrapper(*self TSRMLS_CC);
        obj->handle = retval.handle = ::zend_objects_store_put(obj,
                reinterpret_cast< ::zend_objects_store_dtor_t>(&__dtor_wrapper),
                reinterpret_cast< ::zend_objects_free_object_storage_t>(
                    &__delete_wrapper),
                reinterpret_cast< ::zend_objects_store_clone_t>(
                    &__cctor_wrapper)
                TSRMLS_CC);
        retval.handlers = ::zend_get_std_object_handlers();
        return retval;
    }

    static void __dtor_wrapper(zo_wrapper* obj TSRMLS_DC) {
        if (obj->data_initialized)
            reinterpret_cast<object_type*>(obj->data)->~object_type();
    }

    static void __delete_wrapper(zo_wrapper* obj TSRMLS_DC) {
        delete obj;
    }

    static void __cctor_wrapper(zo_wrapper* obj, zo_wrapper** cloned_obj TSRMLS_DC) {
        *cloned_obj = new zo_wrapper(*obj);
    }
};

template<typename T_>
T_* object_retriever<T_>::operator()(INTERNAL_FUNCTION_PARAMETERS) const
{
    return reinterpret_cast<T_*>(
            reinterpret_cast<typename klass<T_>::zo_wrapper*>(
                ::zend_objects_get_address(this_ptr TSRMLS_CC))->data);
}

template<typename T_, typename Tctor_args_>
static klass<T_>& def_class(char const* name, Tctor_args_ args TSRMLS_DC)
{
    klass<T_>* retval = new klass<T_>(name);
    char lowercased_name[retval->name_length + 1];
    retval->module = EG(current_module);
    retval->ctor(args);
    ::zend_str_tolower_copy(lowercased_name, retval->name, retval->name_length);
    ::zend_hash_update(CG(class_table), lowercased_name, retval->name_length + 1,
            &retval, sizeof(zend_class_entry*), NULL);
    return *retval;
}

template<typename T_>
static klass<T_>& def_class(char const* name TSRMLS_DC)
{
    return def_class<T_, ::boost::mpl::vector0<> >(name, ::boost::mpl::vector0<>() TSRMLS_CC);
}

} } // namespace mozo::php

template<typename T_>
void intrusive_ptr_add_ref(::mozo::php::klass<T_>* ptr)
{
    ++ptr->refcount;
}

template<typename T_>
void intrusive_ptr_release(::mozo::php::klass<T_>* ptr)
{
    ::destroy_zend_class(&ptr);
}
#endif /* MOZO_PHP_KLASS_DEFINED */

#ifndef MOZO_PHP_KLASS_STD_CONVERTER_DEFINED
#define MOZO_PHP_KLASS_STD_CONVERTER_DEFINED
#include <mozo/php/converter.hpp>

namespace mozo { namespace php {

template<typename T_>
struct to_native_converter<T_, false> {
    T_ const& operator()(value_ptr const& val TSRMLS_DC) const {
        return *reinterpret_cast<T_ const*>(
                reinterpret_cast<typename klass<T_>::zo_wrapper const*>(
                    zend_objects_get_address(
                        const_cast< ::zval*>(
                            static_cast< ::zval const*>(
                                val.as<value::_OBJECT>()))
                        TSRMLS_CC))->data);
    }

    T_& operator()(value_ptr& val TSRMLS_DC) const {
        return *reinterpret_cast<T_*>(
                reinterpret_cast<typename klass<T_>::zo_wrapper*>(
                    zend_objects_get_address(
                        static_cast< ::zval*>(val.as<value::_OBJECT>())
                        TSRMLS_CC))->data);
    }
};

} } // namespace mozo::php
#endif /* MOZO_PHP_KLASS_STD_CONVERTER_DEFINED */
