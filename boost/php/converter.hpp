//
// Copyright 2008 (C) Moriyoshi Koizumi. All rights reserved.
//
// This software is distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <zend.h>

#ifndef MOZO_PHP_VALUE_PTR_DEFINED
#include <mozo/php/value.hpp>
#endif /* MOZO_PHP_VALUE_PTR_DEFINED */

#ifndef MOZO_PHP_TO_NATIVE_CONVERTER_DEFINED
#define MOZO_PHP_TO_NATIVE_CONVERTER_DEFINED
#include <boost/mpl/bool.hpp>
#include <boost/mpl/or.hpp>
#include <boost/mpl/not.hpp>
#include <boost/type_traits/is_pod.hpp>
#include <boost/type_traits/is_same.hpp>
#include <boost/type_traits/remove_reference.hpp>

namespace mozo { namespace php {

namespace detail {
    template<typename T_>
    struct is_first_class
        :
        boost::mpl::or_<
            boost::is_POD<T_>,
            boost::mpl::or_<
                boost::is_same<T_, ::std::string>,
                boost::mpl::or_<
                    boost::is_same<T_, array>,
                    boost::mpl::or_<
                        boost::is_same<T_, string>,
                        boost::is_same<T_, resource_handle>
                    >
                >
            >
        > {};
}

template<typename Tnative_, bool BisFirstClass_ = detail::is_first_class<Tnative_>::value>
struct to_native_converter {
    Tnative_ operator()(value_ptr const& TSRMLS_DC) const;
    Tnative_& operator()(value_ptr& TSRMLS_DC) const;
};

template<>
struct to_native_converter<long, true> {
    long operator()(value_ptr const& val TSRMLS_DC) const{
        return static_cast<long>(*val.as<value::_LONG>());
    }
};

template<>
struct to_native_converter<int, true> {
    int operator()(value_ptr const& val TSRMLS_DC) const {
        return static_cast<long>(*val.as<value::_LONG>());
    }
};

template<>
struct to_native_converter<double, true> {
    double const& operator()(value_ptr const& val TSRMLS_DC) const {
        return static_cast<double const&>(*val.as<value::_DOUBLE>());
    }
};

template<>
struct to_native_converter< string, true> {
    string const& operator()(value_ptr const& val TSRMLS_DC) const {
        return static_cast<string const&>(*val.as<value::_STRING>());
    }

    string& operator()(value_ptr& val TSRMLS_DC) const {
        return static_cast<string&>(*val.as<value::_STRING>());
    }
};

template<>
struct to_native_converter< ::std::string, true> {
    ::std::string operator()(value_ptr const& val TSRMLS_DC) const {
        return static_cast<string const&>(*val.as<value::_STRING>());
    }
};

template<>
struct to_native_converter<array, true> {
    const array& operator()(value_ptr const& val TSRMLS_DC) const {
        return static_cast<array const&>(*val.as<value::_ARRAY>());
    }

    array& operator()(value_ptr& val TSRMLS_DC) const {
        return static_cast<array&>(*val.as<value::_ARRAY>());
    }
};

template<>
struct to_native_converter<resource_handle, true> {
    resource_handle operator()(value_ptr const& val TSRMLS_DC) const {
        return *val.as<value::_RESOURCE>();
    };
};

} } // namespace mozo::php
#endif /* MOZO_PHP_TO_NATIVE_CONVERTER_DEFINED */

#ifndef MOZO_PHP_TO_VALUE_PTR_CONVERTER_DEFINED
#define MOZO_PHP_TO_VALUE_PTR_CONVERTER_DEFINED
namespace mozo { namespace php {

template<typename Tnative_>
struct to_value_ptr_converter {
    value_ptr operator()(const Tnative_& val TSRMLS_DC) const {
        return value_ptr(new value(val), false);
    }
};

template<>
struct to_value_ptr_converter< ::zval*> {
    value_ptr operator()(::zval* that TSRMLS_DC) const {
        return *reinterpret_cast<value_ptr*>(&that);
    }
};

template<>
struct to_value_ptr_converter< ::zval const*> {
    value_ptr operator()(::zval const* that TSRMLS_DC) const {
        return *reinterpret_cast<value_ptr const*>(&that);
    }
};

template<>
struct to_value_ptr_converter<value_ptr> {
    value_ptr operator()(value_ptr that TSRMLS_DC) const {
        return value_ptr(that);
    }
};

template<>
struct to_value_ptr_converter<value_ptr const&> {
    value_ptr operator()(value_ptr const& that TSRMLS_DC) const {
        return value_ptr(that);
    }
};

} } // namespace mozo::php
#endif /* MOZO_PHP_TO_VALUE_PTR_CONVERTER_DEFINED */

#ifndef MOZO_PHP_VALUE_PTR_UTILS_DEFINED
#define MOZO_PHP_VALUE_PTR_UTILS_DEFINED
namespace mozo { namespace php {

template<typename Tsrc_>
inline value_ptr to_value_ptr(Tsrc_ const& val TSRMLS_DC)
{
    static to_value_ptr_converter<Tsrc_> converter;
    return converter(val TSRMLS_CC);
}

template<typename T_>
inline T_ to_native(value_ptr const& val TSRMLS_DC)
{
    static to_native_converter<typename boost::remove_reference<T_>::type> converter;
    return converter(val TSRMLS_CC);
}

template<typename T_>
inline T_& to_native(value_ptr& val TSRMLS_DC)
{
    static to_native_converter<typename boost::remove_reference<T_>::type> converter;
    return converter(val TSRMLS_CC);
}
} } // namespace mozo::php

#endif /* MOZO_PHP_VALUE_PTR_UTILS_DEFINED */
