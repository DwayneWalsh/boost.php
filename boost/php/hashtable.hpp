//
// Copyright 2008 (C) Moriyoshi Koizumi. All rights reserved.
//
// This software is distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <cstddef>
#include <cstring>
#include <iterator>

#include <boost/assert.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/type_traits.hpp>
#include <boost/call_traits.hpp>

#include <zend.h>
#include <zend_variables.h>
#include <boost/php/detail/value_helpers.hpp>

#ifndef BOOST_PHP_HASHTABLE_KEY_DEFINED
#define BOOST_PHP_HASHTABLE_KEY_DEFINED

namespace boost { namespace php {

class hashtable_key: public ::zend_hash_key {
public:
    hashtable_key(string& v);

    hashtable_key(ulong v) {
        nKeyLength = 0;
        h = v;
    }

    hashtable_key(const char* str,
            ::std::size_t str_len = static_cast< ::std::size_t>(-1));

    operator ::std::string() const {
        if (nKeyLength == 0) {
            return ::boost::lexical_cast< ::std::string>(h);
        } else {
            return ::std::string(arKey, nKeyLength);
        }
    }
};

} } // namespace boost::php

#endif /* BOOST_PHP_HASHTABLE_KEY_DEFINED */

#ifndef BOOST_PHP_SYMTABLE_KEY_DEFINED
#define BOOST_PHP_SYMTABLE_KEY_DEFINED

namespace boost { namespace php {

class symtable_key: public ::zend_hash_key {
public:
    symtable_key(ulong v) {
        nKeyLength = 0;
        h = v;
    }

    symtable_key(string& v) {
        init(v, v.size());
    }

    symtable_key(const char* str,
            ::std::size_t str_len = static_cast< ::std::size_t>(-1)) {
        if (str_len == static_cast< ::std::size_t>(-1)) {
            str_len = ::strlen(str);
        }
        init(str, str_len);
    }

    operator ::std::string() const {
        if (nKeyLength == 0) {
            return ::boost::lexical_cast< ::std::string>(h);
        } else {
            return ::std::string(arKey, nKeyLength);
        }
    }
private:
    void assign_index(::uint _h) {
        arKey = 0;
        nKeyLength = 0;
        h = _h;
    }

    void init(const char* str, ::uint str_len);
};

} } //namespace boost::php

#endif /* BOOST_PHP_SYMTABLE_KEY_DEFINED */

#ifndef BOOST_PHP_HASHTABLE_DEFINED
#define BOOST_PHP_HASHTABLE_DEFINED

namespace boost { namespace php {

template<typename Telem_, typename Tkey_ = hashtable_key>
class hashtable: public ::HashTable {
public:
    typedef Tkey_ key_type;
    typedef Telem_ mapped_type;
    typedef Telem_ data_type;
    typedef ::std::pair<const key_type, mapped_type> value_type;
    typedef ::uint size_type;
    typedef int difference_type;
    typedef ::dtor_func_t destructor_type;

    template<typename Tfirst_, typename Tsecond_>
    struct pair {
        typedef Tfirst_ first_type;
        typedef Tsecond_ second_type;

        pair(typename ::boost::call_traits<Tfirst_>::param_type f,
                typename ::boost::call_traits<Tsecond_>::param_type s)
            : first(f), second(s) {}

        pair& operator=(const pair& that) {
            pair(that).swap(*this);
            return *this;
        }

        void swap(pair& that) throw() {
            ::std::swap(first, that.first);
            ::std::swap(second, that.second);
        }

        Tfirst_ first;
        Tsecond_ second;
    };

    typedef pair<const key_type, mapped_type&> reference;
    typedef pair<const key_type, const mapped_type&> const_reference;

    template<typename Tcntnr_, typename Titer_> class iterator_base {
    public:
        typedef typename Tcntnr_::difference_type difference_type;
        typedef typename std::bidirectional_iterator_tag iterator_category;

    public:
        iterator_base(Tcntnr_* cntnr, const ::HashPosition& pos,
                bool past_last = false)
            : cntnr_(cntnr), pos_(pos), past_last_(past_last) {}

        bool operator==(const Titer_& rhs) const {
            return past_last_ == rhs.past_last_ && pos_ == rhs.pos_;
        }

        bool operator!=(const Titer_& rhs) const {
            return past_last_ != rhs.past_last_ || pos_ != rhs.pos_;
        }

        Titer_& operator++() {
            ::HashPosition next(pos_);
            ::zend_hash_move_forward_ex(
                    const_cast<hashtable*>(cntnr_), &next);
            if (!next) {
                past_last_ = true;
            } else {
                pos_ = next;
            }
            return *static_cast<Titer_*>(this);
        }

        Titer_ operator++(int) {
            Titer_ retval(*static_cast<Titer_*>(this));
            ::HashPosition next(pos_);
            ::zend_hash_move_forward_ex(
                    const_cast<hashtable*>(cntnr_), &next);
            if (!next) {
                past_last_ = true;
            } else {
                pos_ = next;
            }
            return retval;
        }

        Titer_& operator--() {
            if (past_last_) {
                past_last_ = false;
            } else {
                ::zend_hash_move_backwards_ex(
                        const_cast<hashtable*>(cntnr_),
                        &pos_);
            }
            return *static_cast<Titer_*>(this);
        }

        Titer_ operator--(int) {
            Titer_ retval(*static_cast<Titer_*>(this));
            if (past_last_) {
                past_last_ = false;
            } else {
                ::zend_hash_move_backwards_ex(
                        const_cast<hashtable*>(cntnr_),
                        &pos_);
            }
            return retval;
        }

        typename value_type::first_type key() const {
            typename value_type::first_type key(0ul);
            ::zend_hash_get_current_key_ex(
                    const_cast<hashtable*>(cntnr_),
                    const_cast<char**>(&key.arKey),
                    const_cast< ::zend_uint*>(&key.nKeyLength),
                    const_cast< ulong*>(&key.h), 0,
                    const_cast< ::HashPosition*>(
                        &static_cast<const ::HashPosition&>(pos_)));
            return key;
        }

    public: 
        Tcntnr_* cntnr_;
        ::HashPosition pos_;
        bool past_last_;
    };

    class iterator: public iterator_base<hashtable, iterator> {
    public:
        typedef typename hashtable::value_type value_type;
        typedef typename hashtable::reference reference;
        typedef iterator pointer;

    private:
        typedef iterator_base<hashtable, iterator> base_type;

    public:
        iterator(hashtable* cntnr, const ::HashPosition& pos,
                bool past_last = false)
            : base_type(cntnr, pos, past_last) {}

        typename value_type::second_type& data() const {
            typename value_type::second_type* data; 
            ::zend_hash_get_current_data_ex(
                    const_cast<hashtable*>(base_type::cntnr_),
                    reinterpret_cast<void**>(&data),
                    const_cast< ::HashPosition*>(
                        &static_cast<const ::HashPosition&>(
                            base_type::pos_)));
            return *data;
        }

        reference operator*() const {
            return reference(base_type::key(), data());
        }
    };

    class const_iterator: public iterator_base<const hashtable, const_iterator> {
    public:
        typedef typename hashtable::value_type value_type;
        typedef typename hashtable::const_reference reference;
        typedef const_iterator pointer;
        typedef iterator_base<const hashtable, const_iterator> base_type;

    public:
        const_iterator(const hashtable* cntnr, const ::HashPosition& pos,
                bool past_last = false)
            : base_type(cntnr, pos, past_last) {}

        typename value_type::second_type const& data() const {
            typename value_type::second_type* data; 
            ::zend_hash_get_current_data_ex(
                    const_cast<hashtable*>(base_type::cntnr_),
                    reinterpret_cast<void**>(&data),
                    const_cast< ::HashPosition*>(
                        &static_cast< const ::HashPosition&>(base_type::pos_)));
            return *data;
        }

        reference operator*() const {
            return reference(base_type::key(), data());
        }
    };

    typedef iterator pointer;
    typedef const_iterator const_pointer;

protected:
    typedef Bucket bucket_type;

public:
    hashtable(size_type initial_size = 0,
            destructor_type dtor =
                reinterpret_cast<void(*)(void*)>(
                    &detail::value_dtor_fun<Telem_>::impl),
            bool persistent = false,
            bool apply_protection = true) {
        ::zend_hash_init_ex(this, initial_size, NULL, dtor, persistent,
                apply_protection);
    }

    ~hashtable() {
        ::zend_hash_destroy(this);
    }

    size_type size() const {
        return nNumOfElements;
    }

    void clear() {
        ::zend_hash_clean(this);
    }

    void rehash() {
        ::zend_hash_rehash(this);
    }

    mapped_type* insert(const value_type& v) {
        mapped_type* retval;
        if (FAILURE == zend_hash_quick_add(this, v.first.arKey,
                v.first.nKeyLength, v.first.h,
                const_cast<mapped_type*>(&v.second),
                sizeof(mapped_type), reinterpret_cast<void**>(&retval))) {
            return 0;
        }
        detail::value_copy_ctor_fun<Telem_>::impl(retval, v.second);
        return retval;
    }

    mapped_type* update(const value_type& v) {
        mapped_type* retval;
        if (FAILURE == zend_hash_quick_update(this, v.first.arKey,
                v.first.nKeyLength, v.first.h,
                const_cast<mapped_type*>(&v.second),
                sizeof(mapped_type), reinterpret_cast<void**>(&retval))) {
            return 0;
        }
        detail::value_copy_ctor_fun<Telem_>::impl(retval, v.second);
        return retval;
    }

    mapped_type& push_back(const mapped_type& v);

    iterator begin() {
        ::HashPosition pos;
        ::zend_hash_internal_pointer_reset_ex(this, &pos);
        return iterator(this, pos);
    }

    iterator end() {
        ::HashPosition pos;
        ::zend_hash_internal_pointer_end_ex(this, &pos);
        return iterator(this, pos, true);
    }

    const_iterator begin() const {
        ::HashPosition pos;
        ::zend_hash_internal_pointer_reset_ex(
                const_cast<hashtable*>(this), &pos);
        return const_iterator(this, pos);
    }

    const_iterator end() const {
        ::HashPosition pos;
        ::zend_hash_internal_pointer_end_ex(
                const_cast<hashtable*>(this), &pos);
        return const_iterator(this, pos, true);
    }

    mapped_type& operator[](const key_type& k);

    const mapped_type& operator[](const key_type& k) const;

    bool erase(const key_type& k) const {
        return SUCCESS == zend_hash_del_key_or_index(
                const_cast<hashtable*>(this), k.arKey, k.nKeyLength, k.h,
                k.nKeyLength == 0 ? HASH_DEL_INDEX: HASH_DEL_KEY);
    }

    bool contains(const key_type& k) const {
        return zend_hash_quick_exists(
                const_cast<hashtable*>(this), k.arKey, k.nKeyLength, k.h);
    }
};

} } // namespace boost::php

#endif /* BOOST_PHP_HASHTABLE_DEFINED */

#include <boost/php/exceptions.hpp>

#ifndef BOOST_PHP_HASHTABLE_KEY_MEMBERS_DEFINED
#define BOOST_PHP_HASHTABLE_KEY_MEMBERS_DEFINED

namespace boost { namespace php {

inline hashtable_key::hashtable_key(string& v)
{
    if (v.size() == 0) {
        throw std::out_of_range("key length must be greater than 0");
    }
    arKey = v;
    nKeyLength = v.size();
    h = 0;
}

inline hashtable_key::hashtable_key(const char* str, ::std::size_t str_len)
{
    if (str_len == static_cast< ::std::size_t>(-1)) {
        str_len = ::strlen(str);
    }
    if (str_len == 0) {
        throw std::out_of_range("key length must be greater than 0");
    }
    arKey = const_cast<char*>(str);
    nKeyLength = str_len;
    h = 0;
}

} } // namespace boost::php

#endif /* BOOST_PHP_HASHTABLE_KEY_MEMBERS_DEFINED */

#ifndef BOOST_PHP_SYMTABLE_KEY_MEMBERS_DEFINED
#define BOOST_PHP_SYMTABLE_KEY_MEMBERS_DEFINED

namespace boost { namespace php {

inline void symtable_key::init(const char* str, ::uint str_len)
{
    if (str_len == 0) {
        throw std::out_of_range("key length must be greater than 0");
    }
    arKey = const_cast<char*>(str);
    nKeyLength = str_len;
    h = 0;
#if ZEND_MODULE_API_NO < 20071006
    HANDLE_NUMERIC(const_cast<char*>(str), str_len, assign_index(h));
#else
    ZEND_HANDLE_NUMERIC(const_cast<char*>(str), str_len, assign_index(h));
#endif
}

} } // namespace boost::php

#endif /* BOOST_PHP_SYMTABLE_KEY_MEMBERS_DEFINED */

#ifndef BOOST_PHP_HASHTABLE_MEMBERS_DEFINED
#define BOOST_PHP_HASHTABLE_MEMBERS_DEFINED

namespace boost { namespace php {

template<typename Telem_, typename Tkey_>
inline typename hashtable<Telem_, Tkey_>::mapped_type&
hashtable<Telem_, Tkey_>::push_back(const mapped_type& v)
{
    mapped_type* retval;
    if (FAILURE == zend_hash_index_insert(this, 0, &v,
            sizeof(mapped_type), reinterpret_cast<void**>(&retval))) {
        throw runtime_error("failed to add a new entry");
    }
    detail::value_copy_ctor_fun<Telem_>::impl(*retval, v);
    return *retval;
}

template<typename Telem_, typename Tkey_>
inline typename hashtable<Telem_, Tkey_>::mapped_type&
hashtable<Telem_, Tkey_>::operator[](const key_type& k)
{
    mapped_type* retval;
    if (SUCCESS == zend_hash_quick_find(
            this, k.arKey, k.nKeyLength, k.h,
            reinterpret_cast<void**>(&retval))) {
        return *retval;
    }
    retval = insert(value_type(k, mapped_type()));
    if (retval) {
        return *retval;
    }
    throw runtime_error(
            ::std::string("failed to add a new entry [")
            + static_cast< ::std::string>(k) + "]");
}

template<typename Telem_, typename Tkey_>
inline typename hashtable<Telem_, Tkey_>::mapped_type const&
hashtable<Telem_, Tkey_>::operator[](const key_type& k) const
{
    mapped_type* retval;
    if (SUCCESS == zend_hash_quick_find(
            const_cast<hashtable*>(this), k.arKey, k.nKeyLength, k.h,
            reinterpret_cast<void**>(&retval))) {
        return *retval;
    }
    throw runtime_error(
            ::std::string("failed to find a corresponding key [")
            + static_cast< ::std::string>(k) + "]");
}

} } // namespace boost::php

#endif /* BOOST_PHP_HASHTABLE_KEY_MEMBERS_DEFINED */
