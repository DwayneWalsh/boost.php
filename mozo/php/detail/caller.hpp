//
// Copyright 2008 (C) Moriyoshi Koizumi. All rights reserved.
//
// This software is distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef MOZO_PHP_DETAIL_CALLER_HPP
#define MOZO_PHP_DETAIL_CALLER_HPP

#include <cstddef>
#include <boost/mpl/vector.hpp>
#include <boost/preprocessor/cat.hpp>
#include <boost/preprocessor/config/limits.hpp>
#include <boost/preprocessor/repetition/repeat.hpp>
#include <boost/preprocessor/repetition/repeat_from_to.hpp>
#include <boost/preprocessor/repetition/enum_params.hpp>
#include <boost/preprocessor/repetition/enum_trailing_params.hpp>

#include <mozo/php/detail/signature.hpp>

#include <zend.h>

namespace mozo { namespace php {

class caller_base {
public:
    virtual ~caller_base() {}

    virtual void operator()(INTERNAL_FUNCTION_PARAMETERS) {
    }
};

template< typename Tsig_, typename Tretval_ = typename Tsig_::return_value_type, ::std::size_t Narity_ = Tsig_::arity_value::value >
class caller: public caller_base {
public:
    caller(typename Tsig_::function_type) {}
};

#define __MOZO_PHP_CALLER_CONV_TPL(__z__, __idx__, __var__) \
    BOOST_PP_COMMA_IF(__idx__) \
    to_native< typename ::boost::mpl::at<typename Tsig_::arguments, typename ::boost::mpl::int_<__idx__> >::type >(to_value_ptr(*params[__idx__]))

#define __MOZO_PHP_CALLER_INVOCATION_TPL(__z__, __arity__, __var__) \
    fun_(BOOST_PP_REPEAT_##__z__(__arity__, __MOZO_PHP_CALLER_CONV_TPL, _)) \

#define __MOZO_PHP_CALLER_VOID_INVOCATION_TPL(__z__, __arity__, __var__) \
    __MOZO_PHP_CALLER_INVOCATION_TPL(__z__, __arity__, __var__);

#define __MOZO_PHP_CALLER_NONVOID_INVOCATION_TPL(__z__, __arity__, __var__) \
    new(return_value) value(__MOZO_PHP_CALLER_INVOCATION_TPL(__z__, __arity__, __var__));

#define __MOZO_PHP_CALLER_BODY_TPL(__z__, __arity__, __var__, __invoke__) \
    public: \
        caller(typename Tsig_::function_type fun): fun_(fun) {} \
        virtual ~caller() {} \
        virtual void operator()(INTERNAL_FUNCTION_PARAMETERS) { \
            ::std::size_t arity = Tsig_::arity_value::value; \
            ::zend_uint num_params = *((zend_uint*)EG(argument_stack).top_element - 2); \
            if (num_params < arity) { \
                zend_error(E_WARNING, "too few arguments (expected %d, got %d)", arity, num_params); \
                return; \
            } \
            if (num_params > arity) { \
                zend_error(E_WARNING, "too many arguments (expected %d, got %d)", arity, num_params); \
                return; \
            } \
            zval** params = reinterpret_cast<zval**>( \
                    EG(argument_stack).top_element - 2 - num_params ); \
            __invoke__(__z__, __arity__, __var__) \
        } \
    public: \
        typename Tsig_::function_type fun_; \

#define __MOZO_PHP_CALLER_TPL(__z__, __arity__, __var__) \
    template<typename Tsig_, typename Tretval_> \
    class caller<Tsig_, Tretval_, __arity__>: public caller_base { \
    __MOZO_PHP_CALLER_BODY_TPL(__z__, __arity__, __var__, \
            __MOZO_PHP_CALLER_NONVOID_INVOCATION_TPL) \
    }; \
    template<typename Tsig_> \
    class caller<Tsig_, void, __arity__>: public caller_base { \
    __MOZO_PHP_CALLER_BODY_TPL(__z__, __arity__, __var__, \
            __MOZO_PHP_CALLER_VOID_INVOCATION_TPL) \
    };

BOOST_PP_REPEAT_FROM_TO(0, BOOST_MPL_LIMIT_VECTOR_SIZE, __MOZO_PHP_CALLER_TPL, _);

#undef __MOZO_PHP_CALLER_CONV_TPL
#undef __MOZO_PHP_CALLER_BODY_TPL
#undef __MOZO_PHP_CALLER_TPL
#undef __MOZO_PHP_CALLER_INVOCATION_TPL
#undef __MOZO_PHP_CALLER_NONVOID_INVOCATION_TPL
#undef __MOZO_PHP_CALLER_VOID_INVOCATION_TPL

template<typename Tsig_>
inline caller_base* create_caller(const Tsig_& sig)
{
    return new caller<Tsig_>(sig.impl);
}

} } // namespace mozo::php

#endif /* MOZO_PHP_DETAIL_CALLER_HPP */
