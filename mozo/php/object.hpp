//
// Copyright 2008 (C) Moriyoshi Koizumi. All rights reserved.
//
// This software is distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <cstddef>
#include <new>
#include <zend.h>
#include <zend_objects_API.h>

#ifndef MOZO_PHP_OBJECT_DEFINED
#define MOZO_PHP_OBJECT_DEFINED
namespace mozo { namespace php {

class object: public ::zend_object {
public:
#ifdef ZTS
    object(::zend_class_entry const& TSRMLS_DC);
#endif
    object(::zend_class_entry const&);
    object(object const&);
    ~object();

    static void* operator new(std::size_t sz) {
        return emalloc(sz);
    }

    static void operator delete(void* p) {
        efree(p);
    }
};
} }
#endif /* MOZO_PHP_OBJECT_DEFINED */

#ifndef MOZO_PHP_OBJECT_MEMBER_DEFINED
#define MOZO_PHP_OBJECT_MEMBER_DEFINED
namespace mozo { namespace php {
#if (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION == 1 && PHP_RELEASE_VERSION > 2) || (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION > 1) || (PHP_MAJOR_VERSION > 5)
#ifdef ZTS
inline object::object(::zend_class_entry const& _ce TSRMLS_DC)
{
    ::zend_object_std_init(this, const_cast< ::zend_class_entry*>(&_ce) TSRMLS_CC);
}
#endif

inline object::object(::zend_class_entry const& _ce)
{
    TSRMLS_FETCH();
    ::zend_object_std_init(this, const_cast< ::zend_class_entry*>(&_ce) TSRMLS_CC);
}

inline object::object(object const& that)
{
    TSRMLS_FETCH();
    ::zend_object_std_init(this, const_cast< ::zend_class_entry*>(that.ce) TSRMLS_CC);
    // it is ok to pass 0 as zend_object_value and zend_object_handle
    // since __clone() is never called.
    ::zend_object_value dummy = { 0, NULL };
	::zend_objects_clone_members(this, dummy, const_cast<object*>(&that),
            0 TSRMLS_CC);
}

inline object::~object()
{
    TSRMLS_FETCH();
    ::zend_object_std_dtor(this TSRMLS_CC);
}
#else
inline object::object(::zend_class_entry const& _ce)
{
	ALLOC_HASHTABLE(properties);
	::zend_hash_init(properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    ce = const_cast< ::zend_class_entry*>(&_ce);
    guards = NULL;
}

inline object::object(object const& that)
{
    TSRMLS_FETCH();
	ALLOC_HASHTABLE(properties);
	::zend_hash_init(properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    ce = const_cast< ::zend_class_entry*>(that.ce);
    guards = NULL;
    // it is ok to pass 0 as zend_object_value and zend_object_handle
    // since __clone() is never called.
    ::zend_object_value dummy = { 0, NULL };
	::zend_objects_clone_members(*this, &dummy, const_cast< ::zend_object*>(&that),
            0 TSRMLS_CC);
}

inline object::~object()
{
    if (guards) {
        ::zend_hash_destroy(guards);
        FREE_HASHTABLE(guards);
    }

    if (properties) {
        ::zend_hash_destroy(properties);
        FREE_HASHTABLE(properties);
    }
}
#endif /* (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION == 1 && PHP_RELEASE_VERSION > 2) || (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION > 1) || (PHP_MAJOR_VERSION > 5) */
} } // namespace mozo::php
#endif /* MOZO_PHP_OBJECT_MEMBER_DEFINED */

#ifndef MOZO_PHP_SENSIBLE_OBJECT_DEFINED
#define MOZO_PHP_SENSIBLE_OBJECT_DEFINED
namespace mozo { namespace php {
class sensible_object;
} } // namespace mozo::php

void intrusive_ptr_add_ref(::mozo::php::sensible_object*);
void intrusive_ptr_del_ref(::mozo::php::sensible_object*);

namespace mozo { namespace php {

class sensible_object: public object
{
    friend void ::intrusive_ptr_add_ref(sensible_object*);
    friend void ::intrusive_ptr_del_ref(sensible_object*);
public:
#ifdef ZTS
    sensible_object(::zend_class_entry const& ce TSRMLS_DC)
        : object(ce TSRMLS_CC) {}
#endif
    sensible_object(::zend_class_entry const& ce): object(ce) {}

protected:
#ifdef ZTS
    void add_ref(TSRMLS_D) {
        ::zend_objects_store_add_ref_by_handle(handle TSRMLS_CC);
    }

    void del_ref(TSRMLS_D) {
        ::zend_objects_store_del_ref_by_handle(handle TSRMLS_CC);
    }
#endif
    void add_ref() {
        TSRMLS_FETCH();
        ::zend_objects_store_add_ref_by_handle(handle TSRMLS_CC);
    }

    void release() {
        TSRMLS_FETCH();
        ::zend_objects_store_del_ref_by_handle(handle TSRMLS_CC);
    }

public:
    mutable ::zend_object_handle handle;
};

} }

inline void intrusive_ptr_add_ref(::mozo::php::sensible_object* p)
{
    p->add_ref();
}

inline void intrusive_ptr_del_ref(::mozo::php::sensible_object* p)
{
    p->release();
}
#endif /* MOZO_PHP_SENSIBLE_OBJECT_DEFINED */
